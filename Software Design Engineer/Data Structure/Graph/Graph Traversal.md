# Graph Traversal (图的遍历)
> CreateAt: The 9th of March, 2025  

- [Graph Traversal (图的遍历)](#graph-traversal-图的遍历)
  - [脑图](#脑图)
  - [The definition of traversal (遍历的定义)](#the-definition-of-traversal-遍历的定义)
  - [Depth First Search, DFS, (深度优先搜索)](#depth-first-search-dfs-深度优先搜索)
    - [过程](#过程)
    - [时间复杂度](#时间复杂度)
    - [示例](#示例)
  - [Breadth First Search, BFS, (广度优先搜索)](#breadth-first-search-bfs-广度优先搜索)
    - [过程](#过程-1)
    - [时间复杂度](#时间复杂度-1)
    - [示例](#示例-1)


## 脑图
![Graph Traversal Mind](./Resouces/Graph%20Traversal%20Mind.png)

## The definition of traversal (遍历的定义)
给定一个连通图G=(V,E),从图中的某个顶点出发, 经过一定的路线访问图中的所有顶点, 使每个顶点被访问且只访问一次, 这一过程称为图的遍历.  
图的遍历与树的遍历很相似, 通常有深度优先搜索(对应先序遍历)和深度优先搜索(对应层序遍历). 它们的搜索顺序和树的一样, 但也许考虑处理不同之处, 具体在下面.
图的遍历和树的遍历不同之处:
1.  树的遍历是从跟结点开始, 图的遍历可以从图中任一顶点出发. 
2.  对于图, 任何两个顶点间都可能存在边, 因此图可能包含回路. (从一个顶点出发, 经过若干顶点之后, 可能又回到了前面访问过的顶点)
    1.  方案1思路:在遍历图的顶点时, 对每个顶点增加访问标志, 表明是否被访问过.  从而解决回路问题.
3.  由于图可能是不连通的, 因此从一个顶点出发, 可能永远到达不了图的另一部分. (通常这样必须从另一连通图的分量重新开始遍历, 会产生两棵树)

## Depth First Search, DFS, (深度优先搜索)
类似树的`先序遍历` 

### 过程
1.  选择图中任意顶点作为起始顶点, 将它设未当前顶点.
2.  访问当前顶点v, 输出或存储v的信息.
3.  将v的访问标志置为已访问.(防止回路)
4.  如果v的邻接点中存在未被访问的顶点w, 则将w设为当前顶点, 转 2) 继续; 否则转5).
5.  回退到直至存在有未被访问的邻接点的顶点u, 转4); 若无法回退时(到顶了已经没有可以回调的顶点), 转6).
6.  如果所有顶点均已访问, 则遍历结束, 否则选择未被访问的另一个顶点作为起始顶点, 继续上述过程(这种情况是整个图中>1个的连通图, 此时会产生>1棵树).
7.  

### 时间复杂度
时间复杂度由存储结构决定. 
*   当用邻接矩阵作为储结构
    遍历边的时间复杂度O(|V|); 遍历所有顶点的时间复杂度O(|V|^2), |V|是顶点个数
*   当用邻接表作为存储结构
    遍历边的时间复杂度O(|E|); 遍历所有顶点的时间复杂度O(|E|+|V|), |E|是边数, |V|是顶点个数.

### 示例
可以利用栈自带的"后进先出"的特性来存储遍历中的顶点, 再用一个一维数组记录访问过的顶点.
![Graph Traversal DFS Sample](./Resouces/Graph%20Traversal%20DFS%20Sample.jpg)


## Breadth First Search, BFS, (广度优先搜索)
类似树的`层序遍历`

### 过程
1.  选择图中任意顶点作为起始顶点, 将它设为当前顶点, 将它入队列, 并将其标记为已被访问.
2.  队列为空时,转5); 队列不为空时, 出队列, 设处队列的顶点为w.
3.  输出 w的信息
4.  找到与顶点w相邻接且未被访问过的顶点序列w1,w2,...wk, 依次入队列, 转2).
5.  如果所有顶点都被访问过, 则遍历结束, 否则选择未被访问的顶点作为起始顶点, 继续上述过程(这种情况是整个图中>1个的连通图, 此时会产生>1棵树)..

### 时间复杂度
跟深度优先搜索一样

### 示例
利用队列`先进先出的特性`来存储遍历中的顶点.
用图6-10a的图作示例.
从顶点v0开始,入队列且标记为已访问, 然后出队列访问它的邻接顶点, 得到v1,v2, 将这两个顶点依次入队列并打上已访问标记. 然后出队列得到v1, 访问它的邻接顶点, 得到v0, v3,v4, 由于v0被访问过可以抛弃, 并依次将有效的顶点入队列. 此时队列中的顶点有[v2,v3,v4]. 再出队列得到v2, 访问它的邻接顶点得到v5,v6, 由于不存在被访问过的顶点, 可依次入队列, 继续上面的过程; 当从队列中得到的顶点, 它的所有邻接点都已被访问过了, 则不用再入队列. 直到队列为空, 此时遍历完毕. 
![Graph Traversal DFS Sample](./Resouces/Graph%20Traversal%20DFS%20Sample.jpg)
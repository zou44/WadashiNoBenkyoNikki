# 图的存储
> CreateAt: The 3rd of March, 2025  

- [图的存储](#图的存储)
  - [脑图](#脑图)
  - [介绍](#介绍)
  - [顺序存储结构](#顺序存储结构)
    - [邻接矩阵 (Adjacency Matrix)](#邻接矩阵-adjacency-matrix)
      - [定义](#定义)
      - [特性](#特性)
      - [公式](#公式)
      - [带权图](#带权图)
      - [示例](#示例)
    - [边集数组](#边集数组)
  - [链式存储结构](#链式存储结构)
    - [邻接表 (Adjacency List)](#邻接表-adjacency-list)
      - [定义(基于数组)](#定义基于数组)
      - [特点](#特点)
      - [对于带权图](#对于带权图)
      - [别名](#别名)
      - [特例](#特例)
      - [邻接表示例](#邻接表示例)
    - [十字链表](#十字链表)
    - [邻接多重表](#邻接多重表)
  - [邻接表和邻接矩阵的比较](#邻接表和邻接矩阵的比较)
    - [选择](#选择)


## 脑图
![Storage Mind](./Resouces/Storage%20Mind.png)

## 介绍
图的存储结构非常多, 但总的可以分为两大类, 分别为顺序存储和链式存储. 顺序存储结构以邻接矩阵为代表，链式存储结构以邻接表为代表.

## 顺序存储结构
### 邻接矩阵 (Adjacency Matrix)
#### 定义
设G=(V,E), |V|=n是一个无向图或有向图, 其中V={v1,v2,...,vn}是顶点的集合,E是边集合, n是顶点数量. 图G的邻接矩阵A是一个n*n的矩阵的二维数组, 其定义如下:
$$
A[i][j]=
\begin{cases}
1,\quad 若(vi,vj)x \in E\\
0, \quad 若(vi,vj)x \notin E
\end{cases}
$$
#### 特性
1.   矩阵的对称性:无向图的邻接矩阵是对称的, 因此存储时可只存一半,即对角线.  有向图则不一定.
2.   顶点的度: 对于无向图, 顶点Vi的度是邻接矩阵的第i行(或列)中值不为0的元素个数; 对于有向图, 第i行(或列, 通常是行)中值不为0的元素个数是顶点Vi的出度OD(Vi), 第j列的非0元素个数是顶点Vj的入度ID(Vj).
3.   邻接矩阵的存储空间与顶点个数有关, 为O(|V|^2).   

#### 公式  
1.  边的总数: 在无向图中，`边的总数量=矩阵中1的总数/2`; 在有向图中，`边的总数量=矩阵中1的总数`.

#### 带权图
如果图中从Vi到Vj存在一条边, 则邻接矩阵中位于i行j列的元素值为边(Vi,Vj)的权Wij, 否则值为∞, 表示无穷.
定义如下:
$$
A[i][j]=
\begin{cases}
W_{wj} \quad 若(v_i,v_j)x \in E \quad 0 \leq i,j \leq n-1 \\
∞ \quad 若(v_i,v_j)x \notin E \quad 0 \leq i,j \leq n-1
\end{cases}
$$

#### 示例
G1:无向图; G2:带权有向图
![Storage Adjacency Matrix](./Resouces/Storage%20Adjacency%20Matrix.png)

### 边集数组
不展开

## 链式存储结构
### 邻接表 (Adjacency List)
#### 定义(基于数组)
它是使用单链表存储图中顶点的邻接点的一种存储结构. 每个顶点的所有`邻接点`存储在对应的一个单链表中.   
设图G=(V,E), 则G的邻接表由一个一维数组和n=|V|个链表组成, 一维数组包含n个元素(即顶点, 顶点的标号一定是有序的), 每个元素包含`顶点信息的域(存储顶点信息)`和一个`指针域(指向单链表)`.与顶点Vi(0<=i<=n-1)邻接的所有顶点组成一个单链表, 其表头指针保存在一维数组下标为i的元素的指针域中.  
单链表的每个结点有两个域:一个是顶点域, 存储邻接顶点在一维数组的下标(key);另一个是指针域,指向下一个邻接点.   
[示例](#邻接表示例)

#### 特点
1.  数量:看示例图可知, 表示n个顶点和e条边的无向图时, 需要一个由n个元素组成的顺序表和由总共2e个结点组成的n个单链表. 而在表示由n个顶点、e条边的有向图时,需要一个由n各元素组成的顺序表和由总共e个结点组成的n个单链表. 

#### 对于带权图
扩展了邻接表的结构, 在邻接表每个结点增加一个`权值域`, 用来存储两个顶点间的边的权值.  [示例](#邻接表示例)

#### 别名
邻接表=邻接点表=边链表

#### 特例
-   基于指针的邻接表  
    该邻接表虽然补充了数组邻接表不好删除和插入的问题, 但同时也增加了时间复杂度.
    其原理就是将一维数组换成链表, 每个结点有三个域分别是: 顶点信息域, 指向下一个顶点的指针域, 指向邻接点表的指针. 邻接点表中的结构只是将原本存储数组下标(key),的顶点下标域改为指向顶点的结点域.  
    ![Storage Adjacency List Linked](./Resouces/Storage%20Adjacency%20List%20Linked.png)

#### 邻接表示例
![Storage Adjacency List](./Resouces/Storage%20Adjacency%20List.jpg)

### 十字链表
不展开

### 邻接多重表
不展开

## 邻接表和邻接矩阵的比较
1.  空间复杂度: 邻接矩阵O(n2), 邻接表O(n+e). n是顶点数, e是边数
    -   当图中的边数小于顶点数(邻接矩阵是n^2, 越小则越浪费)时: 邻接矩阵成为`稀疏矩阵`时, 空间有极大浪费. 这种情况下适合使用邻接表.
    -   当图中的边数大于顶点数时: 此时邻接矩阵的利用率较高. 而邻接表这时候需要额外分配空间存储边信息.
2.  时间复杂度: 邻接矩阵O(1), 邻接表O(k). k是所选顶点的度
    -   矩阵中判断是否存在边直接访问即可
    -   而邻接表这需要遍历对应的链表
### 选择
当邻接矩阵的边数大于顶点数时, 适合使用邻接矩阵, 否则适合使用邻接表.
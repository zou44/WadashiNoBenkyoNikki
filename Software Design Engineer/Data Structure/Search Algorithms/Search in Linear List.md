# Search in Linear List (线性表的查找)


## 静态查找
指被查找对象中的元素通常是不变的, 即没插入删除操作.

### 顺序查找
-   使用条件  
    无
-   基本思想  
    从表的一端开始，逐个将记录的关键字和给定值比较，若找到一个记录的关键字与给定值相等，则查找成功；若整个表中的记录均比较过，仍未找到关键字等于给定的记录，则查找失败。  
    `大白话: 拿着给定值与集合中所有元素逐个比较`
-   平均查找长度  
    等概率的情况下Pi=1/n; 最坏的情况要经过n次比较才能找到, 所以Ci=i+1(注:这里+1是为了确定查找失败的情况, 具体看下面)  
    ASL= 1/n * Σ(下标:i=0 上标:n-1)i+1 = (n+1)/2
    
    如何推导成(n+1)/2?  
    使用`前n项和公式`将1/n * Σ(下标:i=0 上标:n-1)i+1转成(n+1)/2.
    过程:
    前n项和公式=Sn=n(a1+an)/2, n是项数, a1是首项, an是末项.  
    将Σ套入到前n项和公式中:  
    Σ(下标:i=0 上标:n-1)i+1=(0+1)+(1+1)+(2+1)+...+n=1+2+3+...+n=n(1+n)/2  
    (n-1是因为下标从0开始, 所以还是n项)  
    整合得:(1/n)*n(1+n)/2=交叉相乘化简=1+n/2  
  
    为什么 Ci=i+1?    
    假设有一个线性表L={1,2,3,4,5}，要查找元素 6。按照顺序查找的方法，需要从第一个元素 1 开始，依次与每个元素进行比较，直到比较完最后一个元素 5，发现没有找到元素 6，此时一共进行了 5 次比较，再加上最后一次确定查找失败的比较，总共进行了
    5+1=6次比较.  

-   示例  
    大白话： 从线性表L中找到n所需的平均次数
    例 设有 L={a,b,c,d,e,f,g}; n=e
    则有 找到L中的e需要5次。所以套入公式 k=(5+1)/2
    
    大白话：求整个线性表中平均的查找长度
    即 线性表l={a,b,c,d,e,f,g} 
    导入公式 k=(1+7)/2=4

-   自组织线性表  
    当所有关键字出现频率不一样时, 可以根据关键字的频率从高到底进行排序, 这样可显著提升查询效率, 这种方式称为"自组织线性表"


### 折半查找 or 二分查找
-   使用条件  
    表中元素按照有序的方式排列好了 (从小到大或从大到小)
-   思路: 说白了，就是每次都调整 low和high到要找关键字的区间内，但不包括mid。如上述第一次查找时，确认关键字在mid的左边，那么需将high调整到mid-1 (反之在右边的话要将low调整到mid+1)。再从 ( low + high ) / 2 = mid 重新判断在左边还是右边，再次循环上述过程。直到mid=查找关键字或候选区为空.  
    `注意 low mid high可能存在全部相等或部分相等的情况。`
-   平均查找 (概率相等的情况下)  
    log(下标:2 n) + 1次
-   时间复杂度   
    O(log(下标:2 n))

### 索引顺序查找 or 分块查找
-   使用条件  
    适用于数据量较多的情况
    
-   思路  
    该查找发结合了顺序查找和折半查找的一种算法.   
    
    初步处理:  
    第一步: 首页将集合按规则分成若干小集合, 小集合中的元素是否有序无所谓, 但小集合与小集合间必须有序, 即第一个小集合中的所有元素都小于第二个小集合中的所有元素, 第二小集合都小于第三小集合, 以此类推.   

    第二步: 将每个小集合中最大的元素取出来, 按小集合的顺序保存在一个一维数组中, 这个数组可称为索引表, 因为小集合有序所以索引表是一个有序表.  
    
    查找的基本思路: 因索引表是有序的, 当确定关键字所在的小集合时, 使用折半查找. 当确定到了具体的小集合后可用顺序查找逐个比较最终确认到具体的元素. 

-   平均查找时间
    ASL=log(下标:2 n) + (n+1)/2

## 动态查找
指的是查找对象中的元素并不是固定的, 即有插入删除操作.

### 二叉查找树 Binary Serach Tree, NST
-   定义
    -   若它的左子树不为空, 则左子树所有结点的关键字值都小于它的根节点关键字值.
    -   若它的右子树不为空, 则右子树所有结点的关键字值都大于它根节点关键字值
    -   它的左子树、右子树也都是二叉树, 也符合以上条件.
-   使用条件
    无
-   思路  
    核心是二分查找. 将数据以二分查找规则进行组织, 便于最大程度发挥二分查找的特点.
-   步骤
    


### 平衡树排序
### B树

## 其他

### 散列